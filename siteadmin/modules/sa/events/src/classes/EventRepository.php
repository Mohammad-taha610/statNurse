<?php

namespace sa\events;

use Recurr\Rule;
use Recurr\Transformer\ArrayTransformer;
use Recurr\Transformer\ArrayTransformerConfig;
use sacore\application\app;
use sacore\application\DateTime;
use sacore\application\DefaultRepository;
use sacore\application\ioc;
use sacore\application\modRequest;
use sacore\utilities\doctrineUtils;

/**
 * EventRepository
 *
 * This class was generated by the Doctrine ORM. Add your own custom
 * repository methods below.
 */
class EventRepository extends DefaultRepository
{
    public function getEventRecurrences($id, $limit = 20, $offset = 0)
    {
        /** @var Event $event */
        $event = ioc::getRepository('Event')->find($id);

        /** @var EventRecurrenceRepository $recurrenceRepository */
        $recurrenceRepository = app::$entityManager->getRepository(ioc::staticResolve('EventRecurrence'));

        //The offset is zero because these set recurrences should all be included first
        $recurrences = doctrineUtils::getEntityCollectionArray(
            $recurrenceRepository->findByEvent($event, 0, $limit)
        );

        $recurrenceData = [];
        $createdRecurrences = [];
        foreach ($recurrences as $recurrence) {
            $singleArray = [];
            $singleArray['start_date'] = $recurrence['start']->format('m/d/Y');
            $singleArray['start_time'] = $recurrence['start']->format('h:i A');

            $singleArray['end_date'] = $recurrence['end']->format('m/d/Y');
            $singleArray['end_time'] = $recurrence['end']->format('h:i A');
            $singleArray['recurrenceUniqueId'] = $recurrence['recurrenceUniqueId'];
            $singleArray['eventId'] = $id;
            $singleArray['recurrenceId'] = $recurrence['id'];
            $singleArray['exists'] = $recurrence['recurrenceExists'];

            //Only add to this array so that we can use Recur/Rule to order the recurrences
            $createdRecurrences[$recurrence['recurrenceUniqueId']] = $singleArray;
        }

        $rruleString = $event->getRecurrenceRules();
        $startDate = $event->getStartDate();
        $endDate = $event->getEndDate();
        $until_date = $event->getUntilDate();

        $rrule = new Rule($rruleString, $startDate, $endDate);
        if (! is_null($until_date)) {
            $rrule->setUntil($until_date);
        }
        $transformer = new ArrayTransformer();
        $times = $transformer->transform($rrule);

        $count = 0;
        //Maybe should be a repo function for Event?
        foreach ($times as $time) {
            if ($count < $offset) {
                $count++;

                continue;
            }
            if ($limit < $count) {
                //If this is after the until date kill it
                break;
            }
            $count++;
            $start_date_unique_id = $time->getStart()->format('mdY');

            $end_date_unique_id = $time->getEnd()->format('mdY');
            $uniqueId = $start_date_unique_id.'-'.$end_date_unique_id;
            if (in_array($uniqueId, array_keys($createdRecurrences))) {
                if ($createdRecurrences[$uniqueId]['exists']) {
                    $recurrenceData[] = $createdRecurrences[$uniqueId];
                }

                continue;
            }
            $singleArray = [];
            $singleArray['start_date'] = $time->getStart()->format('m/d/Y');
            $singleArray['start_time'] = $time->getStart()->format('h:i A');

            $singleArray['end_date'] = $time->getEnd()->format('m/d/Y');
            $singleArray['end_time'] = $time->getEnd()->format('h:i A');
            $singleArray['recurrenceUniqueId'] = $uniqueId;
            $singleArray['eventId'] = $id;
            $singleArray['recurrenceId'] = 0;

            //Set the edit route to be a create
            $singleArray['id'] = 0;
            $recurrenceData[] = $singleArray;
        }

        return $recurrenceData;
    }

    public function findByMonth(Datetime $date, $category = null)
    {
        $month = new DateTime($date->format('Y-m'));
        $nextMonth = new DateTime(date('Y-m', strtotime('+1 month', strtotime($date->format('Y-m')))));

        $result = $this->getRecurrencesBetweenDates($month, $nextMonth, $category);

        return $result;
    }

    //Redundant function, we might want to get rid of it but I kind of like it
    public function fillFullCalendar(Datetime $start, DateTime $end, $category = null)
    {
        $result = $this->getEventsAndRecurrencesBetweenDates($start, $end, $category);

        return $result;
    }

    //Probably needs a better name
    public function getEventsAndRecurrencesBetweenDates(DateTime $dateTime1, DateTime $dateTime2, $category = null)
    {
        $qb = $this->createQueryBuilder('e');

        //States
        //This can absolutely be simplified, but rn I am just trying to finish this up
        $qb->select('e')->where(
            //This is for 'normal events' they have a start date and an end date, if they reoccur there is a until date set
            $qb->expr()->andX($qb->expr()->gte('e.start_date', ':firstDate'), $qb->expr()->lte('e.start_date', ':endDate')).' OR '
            .$qb->expr()->andX($qb->expr()->gte('e.end_date', ':firstDate'), $qb->expr()->lte('e.end_date', ':endDate')).' OR '
            .$qb->expr()->andX($qb->expr()->gte('e.until_date', ':firstDate'), $qb->expr()->lte('e.until_date', ':endDate')).' OR '
            .$qb->expr()->andX($qb->expr()->lte('e.start_date', ':firstDate'), $qb->expr()->gte('e.end_date', ':endDate')).' OR '
            .$qb->expr()->andX($qb->expr()->lte('e.start_date', ':firstDate'), $qb->expr()->gte('e.until_date', ':endDate')).' OR '

            //This is for the weird stuff
            .$qb->expr()->andX($qb->expr()->lte('e.start_date', ':firstDate'), $qb->expr()->isNull('e.until_date')))
            ->setParameter('firstDate', $dateTime1)
            ->setParameter('endDate', $dateTime2)
            ->orderBy('e.start_date', 'ASC');

        if ($category) {
            $qb->andWhere('e.category = :category')
                ->setParameter('category', $category);
        }

        $results = $qb->getQuery()->getResult();
        $auth = modRequest::request('auth.object');

        $member = null;
        $user = null;

        if ($auth) {
            $member = $auth->getAuthMember();
            $user = $auth->getAuthUser();
        }

        $events = [];
        foreach ($results as $event) {
            /** @var EventRecurrenceRepository $recurrenceRepository */
            $recurrenceRepository = app::$entityManager->getRepository(ioc::staticResolve('EventRecurrence'));

            //The offset is zero because these set recurrences should all be included first
            $recurrences = doctrineUtils::getEntityCollectionArray(
                $recurrenceRepository->findByEvent($event)
            );

            $recurrenceData = [];
            $createdRecurrences = [];
            foreach ($recurrences as $recurrence) {
                $eventRecurrence = [];
                $start_date_unique_id = $recurrence['start']->format('mdY');
                $end_date_unique_id = $recurrence['end']->format('mdY');
                $uniqueId = $start_date_unique_id.'-'.$end_date_unique_id;
                $eventRecurrence['start'] = $recurrence['start']->format('Y-m-d\TH:i:s');
                $eventRecurrence['url'] = app::get()->getRouter()->generate('events_single_resources',
                    ['id' => $event->getId(), 'recurrenceId' => $recurrence['id'], 'recurrenceUniqueId' => $uniqueId]);
                $eventRecurrence['end'] = $recurrence['end']->format('Y-m-d\TH:i:s');
                $eventRecurrence['recurrenceUniqueId'] = $uniqueId;
                $eventRecurrence['groupId'] = $event->getId();
//                $singleArray['recurrenceId'] = $recurrence['id'];
                $eventRecurrence['exists'] = $recurrence['recurrenceExists'];

                //Only add to this array so that we can use Recur/Rule to order the recurrences
                $createdRecurrences[$recurrence['recurrenceUniqueId']] = $eventRecurrence;
            }

            if ((! $event->getCategory()) || (! $event->getCategory()->hasPermissionToViewEvent($member, $user))) {
                continue;
            }
            $rruleString = $event->getRecurrenceRules();
            $startDate = $event->getStartDate();
            $endDate = $event->getEndDate();
            $untilDate = $event->getUntilDate();
            $maxRecurrences = $event->getMaxRecurrences();

            if (! is_null($untilDate)) {
                $setUntilDate = ($untilDate < $dateTime2) ? $untilDate : $dateTime2;
            } else {
                $setUntilDate = $dateTime2;
            }

            if (! is_null($maxRecurrences) && $maxRecurrences != 0) {
                $rrule = new Rule($rruleString, $startDate, $endDate);
                $transformer = new ArrayTransformer();
            } else {
                //Currently as the date range increases this, and recurrences that have an extremely long until date will become slow to generate
                //If we need to fix that at some point, the issue is in this class and we would need to clone it and change it or scrap it to fix it
                $rrule = new Rule($rruleString, $startDate, $endDate);
                //May want to move this up to the normal one at some point but idk what the reasonable limit would be for it
                $config = new ArrayTransformerConfig();
                $config->setVirtualLimit(Event::LARGE_NUMBER);
                $transformer = new ArrayTransformer($config);
            }
            //Only show times that are before the later date
            $rrule->setUntil($setUntilDate);
            $times = $transformer->transform($rrule);
            $count = 0;
            foreach ($times as $time) {
                //This might cause missing out on the real recurrences, but I kind of doubt it. Should look at this first if that is the case though
                if (! is_null($maxRecurrences) && $maxRecurrences != 0) {
                    if ($count >= $maxRecurrences && $maxRecurrences != 0) {
                        break;
                    }
                    $count++;
                }
                if ($time->getEnd() < $dateTime1 && $time->getEnd()->format('$d') != $dateTime1->format('$d')) {
                    continue;
                }

                $start_date_unique_id = $time->getStart()->format('mdY');
                $end_date_unique_id = $time->getEnd()->format('mdY');
                $uniqueId = $start_date_unique_id.'-'.$end_date_unique_id;

                if (in_array($uniqueId, array_keys($createdRecurrences))) {
                    if ($createdRecurrences[$uniqueId]['exists']) {
                        $eventRecurrence = $createdRecurrences[$uniqueId];
                        $events[] = ['title' => $event->getName(), 'start' => $eventRecurrence['start'],
                            'end' => $eventRecurrence['end'], 'url' => $eventRecurrence['url']];
                    }

                    continue;
                }
                $eventRecurrence = [];
                $eventRecurrence['start'] = $time->getStart()->format('Y-m-d\TH:i:s');
                $eventRecurrence['url'] = app::get()->getRouter()->generate('events_single_resources', ['id' => $event->getId(), 'recurrenceId' => 0, 'recurrenceUniqueId' => $uniqueId]);
                $eventRecurrence['end'] = $time->getEnd()->format('Y-m-d\TH:i:s');
                $eventRecurrence['recurrenceUniqueId'] = $uniqueId;
//                $events[] = ['title' => $event->getName(), 'group_id' => $event->getId(), 'url' => $eventRecurrence['url'],
//                    'start' => $eventRecurrence['start'], 'end' => $eventRecurrence['end']];
                //On Review not sure we want group id
                $events[] = ['title' => $event->getName(), 'url' => $eventRecurrence['url'],
                    'start' => $eventRecurrence['start'], 'end' => $eventRecurrence['end']];
            }
        }

        return $events;
    }
}
