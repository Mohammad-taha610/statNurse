<?php

namespace sa\events;

use DateTimeZone;
use Doctrine\ORM\Query\Expr\Join;
use sacore\application\app;
use sacore\application\DateTime;
use sacore\application\DefaultRepository;
use sacore\application\ioc;
use sacore\application\modRequest;
use sacore\utilities\doctrineUtils;

/**
 * EventRecurrenceRepository
 *
 * This class was generated by the Doctrine ORM. Add your own custom
 * repository methods below.
 */
class EventRecurrenceRepository extends DefaultRepository
{
    /**
     * Finds a collection of recurrences of an event between the given
     * limit and offset.
     *
     * @param  Event  $event  - The target event of which to find the recurrences.
     * @param  int  $offset - The number of recurrences to skip.
     * @param  int  $limit  - The maximum number of events to return.
     * @return array
     */
    public function findByEvent(Event $event, $offset = 0, $limit = null)
    {
        $qb = $this->createQueryBuilder('r')
            ->leftJoin('r.nurse', 'n')
            ->leftJoin('n.member', 'm')
            ->leftJoin('r.event', 'e')
            ->leftJoin('e.category', 'c')
            ->select('r')
            ->addSelect('n')
            ->addSelect('m')
            ->addSelect('e')
            ->addSelect('c');
        $qb->where($qb->expr()->eq('r.event', ':event'))
            ->setParameter('event', $event);
//            ->setFirstResult($offset);

        if (! is_null($limit)) {
            $qb->setMaxResults($limit);
        }

        $r = $qb->getQuery()->getArrayResult();
        $ra = [];
        foreach ($r as $res) {
            $auth = modRequest::request('auth.object');

            $member = null;
            $user = null;

            if ($auth) {
                $member = $auth->getAuthMember();
                $user = $auth->getAuthUser();
            }

            if (! $res['event']['category']) {
                continue;
            }

            $category = ioc::get('Category', ['id' => $res['event']['category']['id']]);
            if (! $category || ! $category->hasPermissionToViewEvent($member, $user)) {
                continue;
            }
            array_push($ra, $res);
        }

        return $ra;
    }

    /**
     * Returns the recurrences all events within the day of the given date.
     *
     *
     * @return EventRecurrence[]
     */
    public function findByDay(DateTime $date)
    {
        $day = new DateTime($date->format('Y-m-d'));
        $nextDay = new DateTime(date('Y-m-d', strtotime('+1 day', strtotime($date->format('Y-m-d')))));

        return $this->findBetweenDates($day, $nextDay);
    }

    /**
     * Returns the recurrences all events within the month of the given date.
     *
     *
     * @return EventRecurrence[]
     */
    public function findByMonth(DateTime $date, $category = null)
    {
        $month = new DateTime($date->format('Y-m'));
        $nextMonth = new DateTime(date('Y-m', strtotime('+1 month', strtotime($date->format('Y-m')))));

        $result = $this->findBetweenDates($month, $nextMonth, $category);

        return $result;
    }

    /**
     * Returns the recurrences all events within the year of the given date.
     *
     *
     * @return EventRecurrence[]
     */
    public function findByYear(DateTime $date)
    {
        $year = new DateTime($date->format('Y'));
        $nextYear = new DateTime(date('Y', strtotime('+1 year', $date->getTimestamp())));

        return $this->findBetweenDates($year, $nextYear);
    }

    /**
     * Returns the recurrences all events between two dates.
     *
     *
     * @return EventRecurrence[]
     */
    public function findBetweenDates(DateTime $dateTime1, DateTime $dateTime2, $category = null)
    {
        $qb = $this->createQueryBuilder('r');
        $qb->select('r')
            ->innerJoin(ioc::staticGet('Event'), 'e', Join::WITH, 'r.event = e')
            ->where($qb->expr()->lt('r.start', ':endTime').' OR '.$qb->expr()->lt('r.until_date', ':untilDate'))
            ->andWhere($qb->expr()->gte('r.start', ':startTime'))
            ->setParameter('startTime', $dateTime1)
            ->setParameter('endTime', $dateTime2)
            ->setParameter('untilDate', $dateTime2)
            ->orderBy('r.start', 'ASC');

        if ($category) {
            $qb->andWhere('e.category = :category')
                ->setParameter('category', $category);
        }

        $result = $qb->getQuery()->getResult();

        $ra = [];
        foreach ($result as $res) {
            $auth = modRequest::request('auth.object');

            $member = null;
            $user = null;

            if ($auth) {
                $member = $auth->getAuthMember();
                $user = $auth->getAuthUser();
            }

            if ((! $res->getEvent()->getCategory()) || (! $res->getEvent()->getCategory()->hasPermissionToViewEvent($member, $user))) {
                continue;
            }

            array_push($ra, $res);
        }

        return $ra;
    }

    /**
     * Retrieves the recurrences of an event that have not occurred yet.
     *
     * @param  Event  $event  - The event of which to query the recurrences.
     * @param  int  $limit    - The maximum number of recurrences to return.
     * @param  int  $offset   - The number of recurrences to skip.
     * @return EventRecurrence[]
     */
    public function findUpcomingEventRecurrences(Event $event, $limit = 10, $offset = 0)
    {
        $qb = $this->createQueryBuilder('r');
        $query = $qb->select('r')
            ->innerJoin(ioc::staticGet('Event'), 'e', Join::WITH, 'r.event = e')
            ->where($qb->expr()->eq('r.event', ':event'))
            ->andWhere($qb->expr()->gte('r.start', ':startTime'))
            ->setMaxResults($limit)
            ->setFirstResult($offset)
            ->setParameter('event', $event)
            ->setParameter('startTime', (new DateTime('now'))->getTimestamp())
            ->orderBy('r.start', 'ASC')
            ->getQuery();

        $r = $query->getResult();

        $ra = [];
        foreach ($r as $res) {
            $auth = modRequest::request('auth.object');

            $member = null;
            $user = null;

            if ($auth) {
                $member = $auth->getAuthMember();
                $user = $auth->getAuthUser();
            }

            if ((! $res->getEvent()->getCategory()) || (! $res->getEvent()->getCategory()->hasPermissionToViewEvent($member, $user))) {
                continue;
            }
            array_push($ra, $res);
        }

        return $ra;
    }

    /**
     * Retrieves the next X event recurrences that have not occurred yet.
     *
     * @param  int  $limit    - The maximum number of recurrences to return.
     * @param  int  $offset   - The number of recurrences to skip.
     * @return EventRecurrence[]
     */
    public function findAllUpcomingRecurrences($category, $limit = 10, $offset = 0, $group = false)
    {
        $qb = $this->createQueryBuilder('r');
        $qb->select('r')
            ->innerJoin(ioc::staticGet('Event'), 'e', Join::WITH, 'r.event = e')
            ->where('r.end >= :start')
            ->orderBy('r.start', 'ASC')
            ->setMaxResults($limit)
            ->setFirstResult($offset)
            ->setParameter('start', new DateTime());

        if ($category != 'ALL') {
            $qb->andWhere('e.category = :category')
                ->setParameter('category', $category);
        }

        if ($group) {
            $qb->groupBy('r.event');
        }

        $result = $qb->getQuery()->getResult();

        $ra = [];
        foreach ($result as $res) {
            $auth = modRequest::request('auth.object');

            $member = null;
            $user = null;

            if ($auth) {
                $member = $auth->getAuthMember();
                $user = $auth->getAuthUser();
            }

            if ((! $res->getEvent()->getCategory()) || (! $res->getEvent()->getCategory()->hasPermissionToViewEvent($member, $user))) {
                continue;
            }
            array_push($ra, $res);
        }

        return $ra;
    }

    public function createRecurrenceFromEventAndUniqueId($eventId, $recurrenceUniqueId)
    {
        $event = ioc::getRepository('Event')->find($eventId);

        $recurrence = ioc::resolve('EventRecurrence');
        $event->addEventRecurrence($recurrence);
        $recurrence->setEvent($event);
        $recurrence->setRecurrenceUniqueId($recurrenceUniqueId);

        $startDate = DateTime::createFromFormat('mdY', explode('-', $recurrenceUniqueId)[0]);
        $endDate = DateTime::createFromFormat('mdY', explode('-', $recurrenceUniqueId)[1]);
        $startTime = $event->getStartTime();
        $endTime = $event->getEndTime();

        $recurrence->setRecurrenceExists(true);

        $startTimestamp = sprintf('%s %s', $startDate->format('m/d/Y'), $startTime->format('H:i:s'));
        $recurrence->setStart((new DateTime($startTimestamp, new DateTimeZone($event->getTimezone()))));

        $endTimestamp = sprintf('%s %s', $endDate->format('m/d/Y'), $endTime->format('H:i:s'));
        $recurrence->setEnd((new DateTime($endTimestamp, new DateTimeZone($event->getTimezone()))));

        $recurrence->setDescription($event->getDescription());

        app::$entityManager->persist($recurrence);

        //Is there a downside to flushing twice, beyond some simple performance issues? Wondering if this should be set to flush or not.
//        app::$entityManager->flush($recurrence);

        return $recurrence;
    }

    public function getRecurrenceEntityArray($recurrence)
    {
        $event = $recurrence->getEvent();
        $recurrenceArray = doctrineUtils::getEntityArray($recurrence);

        //General
        $this->checkAndSwapArrayKeyIfEmpty($recurrenceArray, $event, 'name', 'getName');
        $this->checkAndSwapArrayKeyIfEmpty($recurrenceArray, $event, 'link', 'getLink');
        $this->checkAndSwapArrayKeyIfEmpty($recurrenceArray, $event, 'description', 'getDescription');

        //Date/Time
        //Todo: This will require special stuff
//        $this->checkAndSwapArrayKeyIfEmpty($recurrenceArray, $event, 'start', 'getStartTime');
//        $this->checkAndSwapArrayKeyIfEmpty($recurrenceArray, $event, 'end', 'getEndTime');

        //Location
        $this->checkAndSwapArrayKeyIfEmpty($recurrenceArray, $event, 'timezone', 'getTimezone');
        $this->checkAndSwapArrayKeyIfEmpty($recurrenceArray, $event, 'location_name', 'getLocationName');
        $this->checkAndSwapArrayKeyIfEmpty($recurrenceArray, $event, 'street_one', 'getStreetOne');
        $this->checkAndSwapArrayKeyIfEmpty($recurrenceArray, $event, 'street_two', 'getStreetTwo');
        $this->checkAndSwapArrayKeyIfEmpty($recurrenceArray, $event, 'city', 'getCity');
        $this->checkAndSwapArrayKeyIfEmpty($recurrenceArray, $event, 'postal_code', 'getPostalCode');
        $this->checkAndSwapArrayKeyIfEmpty($recurrenceArray, $event, 'state', 'getState');

        $this->checkAndSwapArrayKeyIfEmpty($recurrenceArray, $event, 'contact_name', 'getContactName');
        $this->checkAndSwapArrayKeyIfEmpty($recurrenceArray, $event, 'contact_phone', 'getContactPhone');
        $this->checkAndSwapArrayKeyIfEmpty($recurrenceArray, $event, 'contact_email', 'getContactEmail');

        return $recurrenceArray;
    }

    private function checkAndSwapArrayKeyIfEmpty(&$recurrenceArray, $event, $key, $functionName)
    {
        if (is_null($recurrenceArray[$key]) || empty($recurrenceArray[$key])) {
            $recurrenceArray[$key] = call_user_func([$event, $functionName]);
        }

        return $recurrenceArray;
    }
}
